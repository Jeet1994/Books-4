
=head0 Template-Systems

Templates are documents with place-holders that are filled with values
to produce final documents. For example, a corporate letter to send to
all employees in a company, where the name will be personalized.

The usage of templates is a typical methodology to separate code from
presentation, and are especially known for their relevance for web
frameworks that claim to follow the MVC (Model--View--Controller)
software architecture. Templates can be used to generate all type of
text: pure text, HTML, XML or even LaTeX documents.

There is a bunch of templating modules on CPAN. We chose three:

=over

=item C<Text::Template>

A simple template system. Its mark-up language is not based on HTML
notation but very similar to Perl code.

=item C<HTML::Template::Pro>

A derived module from C<HTML::Template>, but using some C<C> code,
making it faster. Its main advantage is being smaller than
C<Template::Toolkit> and quite efficient.

=item C<Template::Toolkit>

The complete template system. It is powerful, configurable and
expendable. Has some dependencies, namely the requirement for a C<C>
compiler.

=back

=head1 Text::Template

X<Module, Text::Template>X<Text::Template>

=begin CPANinfo

B<Version:> 1.45

B<CPAN:> L<http://search.cpan.org/dist/Text-Template>

=end CPANinfo

This module was designed to produce any kind of text files. Its syntax
is not based in HTML or any other known mark-up language, but in Perl
blocks. This makes it easier to understand by any Perl programmer (but
harder for designers, for example).

The module is stable for some time: the last stable version is from
2003! It doesn't have any dependency other than Perl itself, making it
easy to install in any Perl environment.

=head2 *Variable Notation

A template with simple place-holders is easy to define. Just create a
text file (or even a string) and curly bracesN<< If you do not like to
have curly braces as delimiters you can configure C<Text::Template> to
use some other characters. For example, C<< $tmpl->fill_in(DELIMITERS
=> [ '[%', ']%' ]) >> would change the delimiters to C<[%> and C<%]>
respectively. >> to delimit the predefined text from the place-holders
variables:

   Dear { $name }:
   
   I am sorry to inform that you are fired. Your compensation
   is { $compensation{$name} } euro.
   
   Best regards, your boss.

As the example illustrates, you can insert any type of variable
between the curly braces. If the above text is saved in a file named
"C<fire.tmpl>" you can generate the text for a list of employees with
the following code:

=begin Perl

 use Text::Template;

 my $tmpl = Text::Template->new(SOURCE => 'fire.tmpl') or die;

 my %compensation = (John => 100, Mary => 300);

 for my $employee (keys %compensation) {
   my $text = $tmpl->fill_in( HASH => {
                             name => $employee,
                     compensation => \%compensation });
   print $text;
 }

=end Perl

Line 3 creates a new C<Text::Template> object, specifying where the
template file it. If it fails returns an undefined variable. You can
use the C<$Text::Template::ERROR> variable in the C<die> command to
consult what happens when it fails.

Line 8 fills the template for each employee. The C<fill_in> method can
receive the variables to be filled in the template in two different
ways. In this case we are passing a hash reference, where keys are
variable names and their values the respective variable values.

Another option would be to specify a package where the variables will
come from. A variable C<$x> will be replaced by the C<$Package::x>.

  $tmpl->fill_in( PACKAGE => "Foo::Bar");

You can even suppress the package name, and C<Text::Template> will use
the current package. In this case the variables being shared with the
template system should not be declared with C<my> but C<our>:

=begin Perl

 use Text::Template;

 my $tmpl = Text::Template->new(SOURCE => 'fire.tmpl') or die;

 our %compensation = (John => 100, Mary => 300);
 our $name;

 for  $name (keys %compensation) {
   my $text = $tmpl->fill_in();
   print $text;
 }

=end Perl

Take care when using the package approach. If you change variables'
values inside your template, they will be propagated back to your
code.

Another useful option to the C<fill_in> method is C<OUTPUT>. Its value
must be a file handle. The result of filling the template will be
printed to that file instead of being returned. The following code
will create a text file for each employee:

=begin Perl

 use Text::Template;

 my $tmpl = Text::Template->new(SOURCE => 'fire.tmpl') or die;

 our %compensation = (John => 100, Mary => 300);
 our $name;

 for  $name (keys %compensation) {
   open my $fh, ">", "$name.txt" or die;
   $tmpl->fill_in( OUTPUT => $fh );
   close $fh;
 }

=end Perl

=head2 *Complex structures

Did I tell you that you can write any Perl code inside
C<Text::Template> curly braces? But you can. And that is the way you
can add advanced functionality to your template. First, you can format
numbers calling the built-in command C<sprintf>:

  My current debt is { sprintf("%.2f", $value) } euro.

If you pass an array to the C<fill_in> method you can cycle the array
in your code:

  This is my wish list:
  { for $item (@wishlist) { $list .= " * $item\n"; } $list }

What this code does is cycle the C<wishlist> array and construct a
string with the text to be included in the template. At the end, we
return its content. C<Text::Template> makes a special variable C<$OUT>
available in your code, making the above code easier to read:

  This is my wish list:
  { for $item (@wishlist) { $OUT .= " * $item\n"; } $list }

With this variable and Perl code you can do mostly anything in your
template.

=head1 HTML::Template::Pro

X<Module, HTML::Template::Pro>X<HTML::Template::Pro>
X<Module, HTML::Template>X<HTML::Template>

=begin CPANinfo

B<Version:> 0.9504

B<CPAN:> L<http://search.cpan.org/dist/HTML-Template-Pro>

=end CPANinfo

C<HTML::Template::Pro> is an extended version of
C<HTML::Template>. Most of the functionalities are available on both,
but the C<::Pro> is faster as it is partially implemented in C<C>.

=head2 *Variable Notation

These modules were developed to generate HTML (although you can
generate anything with them). The syntax is similar to an HTML tagN<<<
With C<HTML::Template::Pro> is possible to write commands as if they
were XHTML tags: C<< <TMPL_VAR NAME='variable_name'/> >>. >>>:

   <TMPL_VAR NAME=variable_name>

The first part (C<TMPL_VAR>) is the command name (we'll see other
shortly) to include a variable value. Follows a key/value pair
pointing C<NAME> to the name of the place holder. Consider the
following HTML template:

   <p>Dear <TMPL_VAR NAME=name>:</p>
   
   <p>I am sorry to inform that you are fired. Your compensation
   is <TMPL_VAR NAME=compensation> euro.</p>
   
   <p>Best regards, your boss.</p>

This template can be filled with the following code:

=begin Perl

 use HTML::Template::Pro;

 my $tmpl = HTML::Template::Pro->new(filename => 'letter.tmpl');

 my %compensation = (John => 100, Mary => 300);

 for my $name (keys %compensation) {
   $tmpl->param( name         => $name ); 
   $tmpl->param( compensation => $compensation{$name} );
   print $tmpl->output();
 }

=end Perl

Changing the code above to generate a separate HTML file per letter:

=begin Perl

 use HTML::Template::Pro;

 my $tmpl = HTML::Template::Pro->new(filename => 'letter.tmpl');

 my %compensation = (John => 100, Mary => 300);

 for my $name (keys %compensation) {
   $tmpl->param( name         => $name,
                 compensation => $compensation{$name} );

   open my $fh, ">", "$name.html" or die;
   $tmpl->output(print_to => $fh);
   close $fh;
 }

=end Perl

As a final note, although the syntax is meant to simulate normal HTML
tags, you can use them inside HTML tags:

   <img src="<TMPL_VAR NAME=image_url>" />

This can even be simplified, if you prefer.

   <img src="<TMPL_VAR image_url>" />

=head2 *Complex structures

Complex data structures can be managed directly in the
template. C<HTML::Template::Pro> supports conditionals, loops or
complex Perl expressions.

=head1 Template::Toolkit

X<Module, Template::Toolkit>X<Template::Toolkit>


=begin CPANinfo

B<Version:> 2.22

B<CPAN:> L<http://search.cpan.org/dist/Template-Toolkit>

=end CPANinfo




=begin SeeAlso

C<Mason> X<Mason> X<Module, Mason> is a web framework that
incorporates its own template system. Some applications support
C<Mason> syntax for templating via plug-ins.

If your C<HTML::Template> templates are slow check X<Module,
HTML::Template::Compiled>X<HTML::Template::Compiled>
C<HTML::Template::Compiled>, that compiles a template into a Perl
program making it faster.

X<Module, Template::Simple> X<Template::Simple> C<Template::Simple> is
a simple and fast template system. It is written entirely in Perl and
has a modern interface, unlink C<Text::Template> or even
C<HTML::Template>.

X<Module, Text::Template::Simple> X<Text::Template::Simple>
C<Text::Template::Simple> uses the same philosophy from
C<Text::Simple> making Perl itself the templating language. Its main
difference from C<Text::Template> is that the mark-up language has
some extra sugar to configure whether they are place-holders or simple
code blocks with no return text.

=end SeeAlso

=cut

## Local Variables:
##  ispell-local-dictionary: "english"
##  mode: flyspell
## End:
