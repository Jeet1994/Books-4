
=head0 Modern Perl OO

X<Moo>X<Module, Moo> X<Moose>X<Module, Moose> X<Mouse>X<Module, Mouse>
X<OO Programming> Perl always suffered from the lack of a rigid object
oriented system. Although blessed references did the trick for years,
developers felt sorry they did not have support for some common OO
features, like interfaces (or roles), multiple inheritance and
encapsulation.

A few years ago C<Moose> appeared. At first it was quite slow and its
usage was discouraged. Fortunately, in the last years, C<Moose> became
quite fast and includes a lot of relevant and useful features.

Nevertheless, C<Moose> is still quite slow for applications that need
to start every time. That is, in applications like CGI scripts, that
are parsed and run every time a request is made, the overhead of
loading C<Moose> is not acceptable.

To solve this problem some developers started C<Mouse>, a smaller
implementation that does not include all C<Moose> functionalities, but
only the more relevant ones. It maintains the API compatible with
C<Moose>, making it easier to switch whenever needed.

Another implementation, named C<Moo>, claims to be yet smaller and
faster than C<Mouse>, although it does not have much users yet.

Given all these modules share the basic syntax, this chapter structure
will be slightly different from the next ones. First, we will present
C<Moo>, then, what C<Mouse> offers over C<Moo>, and finally, what
C<Moose> offers more than C<Mouse>. This approach will make this
chapter smaller and help the reader when choosing one implementation.

=head1 Moo

X<Moo>X<Module, Moo>

=begin CPANinfo

B<Version:> 0.009008

B<CPAN:> L<http://search.cpan.org/dist/Moo>

=end CPANinfo

C<Moo> uses the usual approach to define objects: use packages (the
Perl equivalent to what we are used to call classes).

=head2 *Attributes

Follows a simple example of a I<Person> object with two attributes,
I<name> and I<phone>. The first is a read only attribute (you can't
change the person name after initializing the object) while the second
has read/write permissions. This information is used by C<Moo> to
define whether to create accessors that are able to set and get
values, or just get values. The I<required> option means that every
time a I<Person> object is created a name must be supplied.

=begin Perl

 package Person;
 use Moo;

 has name  => ( is => 'ro',  required => 1 );
 has phone => ( is => 'rw' );
 1;

=end Perl

Note that the fat arrow is equivalent to a comma, and the parenthesis
are not needed. The first attribute could be defined as:

  has "name", "is", "ro", "required", 1;

but its legibility is not the same. Therefore we will stick to the
usage of the fat arrow together with parenthesis or indentation to
group attribute options.

This object usage is similar to the usage of standard blessed
objects. C<Moo> creates automatically the constructor and accessors.

=begin Perl

 use Person;

 my $person = Person->new(name => 'John');
 print $person->name;

 $person->phone("93453423");
 print $person->phone;

=end Perl

Unlike the next two alternatives, C<Moo> doesn't have a type
system. If you need to guarantee that an attribute keeps a specific
type of data, you need to validate it yourself. That is done adding a
code reference. The next example is a redefinition of the attribute
C<phone> forcing a nine digits string:

=begin Perl

 has phone =>
      is  => 'rw',
      isa => sub {
         die "Need a nine digit string!" unless $_[0] =~ /^\d{9}$/
      };

=end Perl

Attributes can have default values. This is specified using the
C<default> option. It takes a code reference that receives the object,
and should return the new value. Note that you should not rely on
other attributes for this initialization as there is no guarantee that
they were already populated (for that use I<lazy> attributes). As an
example, you can create an attribute C<sex> and define it
automatically to I<female> if not specified.

=begin Perl

 has sex =>
      is => 'ro',
      default => sub { return 'female' };

=end Perl

If the default value need to be computed based on some attributes, or
the task of computing it is time or CPU expensive, you can define the
attribute as I<lazy> (set it to a true value). This way the value will
only be computed when it is first accessed.

When some code should run after a specific attribute is set a
C<trigger> should be used. It is just a code reference that will be
called over the object, with the new value as argument. For instance,
when a phone number is registered, call some method to send a SMS to
the new number acknowledging the change:

=begin Perl

 has phone =>
      is  => 'rw',
      isa => sub {
         die "Need a nine digit string!" unless $_[0] =~ /^\d{9}$/
      },
      trigger => sub {
         send_sms( to => $_[1],
                   msg => "Phone number correctly updated.")
      };

=end Perl

=head2 *Roles

foo bar zbr ugh

=head1 Mouse

X<Mouse>X<Module, Mouse>

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus
sodales pellentesque lectus. Nam sed augue magna, eget gravida
nulla. Aenean vitae augue id orci dignissim pellentesque. Quisque vel
nunc arcu. Quisque pharetra convallis diam eu condimentum. Etiam ipsum
diam, cursus sit amet mollis quis, lobortis dignissim risus. Duis
bibendum facilisis tellus eget ornare. Suspendisse vestibulum, neque
et blandit mattis, tortor eros cursus odio, et aliquam ligula est
imperdiet turpis. Vivamus purus lorem, sodales ut hendrerit quis,
adipiscing in justo. Mauris volutpat metus eget sapien rhoncus
pellentesque. Nunc in ligula id nibh dapibus aliquet. Proin tempus,
nunc tincidunt fringilla sodales, ante erat accumsan ipsum, quis
pretium tortor dui nec velit. Fusce dapibus, erat eget rhoncus
elementum, turpis tortor aliquam risus, quis porta felis est auctor
odio. Suspendisse eu odio non felis vehicula tempus nec sed
turpis. Nullam aliquet lacus eu ligula interdum sit amet pulvinar ante
faucibus.

=head1 Moose

X<Moose>X<Module, Moose>

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus
sodales pellentesque lectus. Nam sed augue magna, eget gravida
nulla. Aenean vitae augue id orci dignissim pellentesque. Quisque vel
nunc arcu. Quisque pharetra convallis diam eu condimentum. Etiam ipsum
diam, cursus sit amet mollis quis, lobortis dignissim risus. Duis
bibendum facilisis tellus eget ornare. Suspendisse vestibulum, neque
et blandit mattis, tortor eros cursus odio, et aliquam ligula est
imperdiet turpis. Vivamus purus lorem, sodales ut hendrerit quis,
adipiscing in justo. Mauris volutpat metus eget sapien rhoncus
pellentesque. Nunc in ligula id nibh dapibus aliquet. Proin tempus,
nunc tincidunt fringilla sodales, ante erat accumsan ipsum, quis
pretium tortor dui nec velit. Fusce dapibus, erat eget rhoncus
elementum, turpis tortor aliquam risus, quis porta felis est auctor
odio. Suspendisse eu odio non felis vehicula tempus nec sed
turpis. Nullam aliquet lacus eu ligula interdum sit amet pulvinar ante
faucibus.

=cut

## Local Variables:
##  ispell-local-dictionary: "english"
##  mode: flyspell
## End:

